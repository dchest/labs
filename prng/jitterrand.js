// @ts-check
/**
 * JitterRand PRNG.
 * XORs randomly generated bytes into the given Uint8Array and returns it.
 *
 * Randomness is generated by measuring timing between permutations and
 * memory accesses, making it vary based on CPU and memory accesses.
 */


// Base number of permutation rounds,
// set to recommened value for Speck-32-128.
var rounds = 37;
var milliseconds = (function () {
    if (typeof performance !== "undefined") {
        return performance.now.bind(performance);
    }
    if (typeof process !== "undefined" && process.hrtime) {
        return function () {
            var t = process.hrtime();
            return (t[0] * 1e9 + t[1]) / 1e6;
        };
    }
    // Less precise timer requires slower permutation,
    // so increase the number of rounds.
    rounds *= 8;
    return Date.now.bind(Date);
})();

function jitterRand(out) {

    function genblock(ctr, s) {
        var len = s.length,
            left = 0,
            right = 1,
            morerounds = 0,
            x, y, i,
            start = milliseconds();

        s[left] = 0;
        s[right] = ctr;

        for (i = 0; i < len * 2; i++) {
            // Add timing and permute
            // (Based on Speck32 with neighboring state values
            // xored with round number as round keys.)
            x = s[left] ^ ((milliseconds() - start) * 5000);
            y = s[right] ^ (i << 16);

            for (var r = 0; r < rounds + morerounds; r++) {
                x = ((x << 24 | x >>> 8) + y) ^ s[(right + r + 1) % len] ^ r;
                y = (y << 3 | y >>> 29) ^ x;
            }

            s[left] = y >>> 0;
            s[right] = x >>> 0;

            // Set new values for morerounds and indexes
            // based on data in current indexes after permutation.
            morerounds = s[right] % (rounds / 2 | 0);
            left = s[left] % len;
            right = (left + 1) % len;
        }

        // Collapse and erase state,
        // leaving result in the first two indexes.
        for (i = 2; i < len - 1; i += 2) {
            s[0] = (s[0] + s[i + 0]) | 0;
            s[1] = (s[1] + s[i + 1]) | 0;
            s[i + 0] = 0;
            s[i + 1] = 0;
        }
    }

    var state = new Uint32Array(256),
        view = new DataView(state.buffer, 0, 8);

    for (var i = 0; i < out.length; i++) {
        if (i % 8 === 0) {
            genblock(i, state);
        }
        out[i] ^= view.getUint8(i % 8);
    }
    state[0] = state[1] = 0;
    return out;
}

module.exports = jitterRand;
